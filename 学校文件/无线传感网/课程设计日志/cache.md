**Ad-hoc flooding**

[实习 13] 无线 Ad-hoc Flooding 网络  267  1: module FloodingM {  2: provides {  3: interface StdControl;  4: interface AMSend as SendFromAPP;  5: interface Receive as RecvToAPP;  6: }  7: uses {  8: interface Timer<TMilli>;  9: interface ParameterInit<uint16_t> as SeedInit;  10: interface Random;  11: interface SplitControl as CommControl;  12: interface AMSend as SendToMAC;  13: interface Receive as RecvFromMAC;  14: }  15: }implementation {  16: message_t SendMsg, RecvMsg, ForwardMsg[MAX_Forward_Buff];  17: Route_Msg NWKF;  18: uint16_t Next_Addr;  19: uint8_t Forward_Buff_Index;  20: uint8_t RTable_Index;  21: uint8_t mySequence;  22: Route_Table RTable[MAX_RTABLE];  23: command error_t StdControl.start() {  24: uint8_t i;  25: uint16_t random_num;  26: call SeedInit.init(TOS_NODE_ID);  27: random_num = call Random.rand16();  28: atomic {  29: Next_Addr = AM_BROADCAST_ADDR;  30: Forward_Buff_Index = 0;  31: RTable_Index = 0;  32: mySequence = (uint8_t) (random_num%0xFF);  33: for (i=0;i<MAX_RTABLE;i++) {  34: RTable[i].FinalDstAddr = UnknownAddr;  35: RTable[i].OrigiSrcAddr = UnknownAddr;  36: RTable[i].Sequence = 0xFF;
实习篇  268  37: }  38: }  39: call CommControl.start();  40: return SUCCESS;  41: }  42: command error_t StdControl.stop() {return SUCCESS;}  43: event void CommControl.startDone(error_t error) {}  44: event void CommControl.stopDone(error_t error) {}  //////////////////////////////////////////////////////////////////////  45: void insertMSGtoRTable(message_t* msg) {  46: Route_Msg pack;  47: memcpy(&pack, call SendToMAC.getPayload(msg), sizeof(Route_Msg));  48 : atomic{  49: RTable[RTable_Index].FinalDstAddr = pack.FinalDstAddr;  50: RTable[RTable_Index].OrigiSrcAddr = pack.OrigiSrcAddr;  51: RTable[RTable_Index].Sequence = pack.Sequence;  52 : RTable_Index++;  53 : RTable_Index %= MAX_RTABLE;  54 : }  55: }  56: bool isRecvPrevious (message_t* msg) {  57: Route_Msg pack;  58: bool return_status = 0;  59: uint8_t i;  60: memcpy(&pack, call SendToMAC.getPayload(msg), sizeof(Route_Msg));  61: for (i=0;i<MAX_RTABLE;i++) {  62: if (RTable[i].FinalDstAddr == pack.FinalDstAddr &&  63: RTable[i].OrigiSrcAddr == pack.OrigiSrcAddr &&  64: RTable[i].Sequence == pack.Sequence)  65: {  66: return_status = 1;  67: break;  68: }  69: }
[实习 13] 无线 Ad-hoc Flooding 网络  269  70: return return_status;  71: }  //////////////////////////////////////////////////////////////////////  72: command error_t SendFromAPP.send(...){  73: Route_Msg Route_M;  74: void *DataPayLoad = call SendToMAC.getPayload(msg);  75: error_t return_status;  76: Route_M.FrameControl = GeneralDataFrame;  77: Route_M.FinalDstAddr = addr;  78: Route_M.OrigiSrcAddr = TOS_NODE_ID;  79: Route_M.Sequence = mySequence;  80: Route_M.TTL = Default_TTL;  ...  81: mySequence++;  82: mySequence %= 0xFF;  83: return_status = call SendToMAC.send(Next_Addr, &SendMsg, sizeof(Route_Msg));  84: if (return_status == SUCCESS)  85: insertMSGtoRTable(&SendMsg);  86: return return_status;  87: }  88: command error_t SendFromAPP.cancel(message_t* msg){  89: return call SendToMAC.cancel(msg);  90: }  91: command uint8_t SendFromAPP.maxPayloadLength(){  92: return call SendToMAC.maxPayloadLength();  93: }  94: command void* SendFromAPP.getPayload(message_t* msg){  95: return call SendToMAC.getPayload(msg);  96: }
实习篇  270  97: event void SendToMAC.sendDone(message_t* msg, error_t error) {  98: signal SendFromAPP.sendDone(msg, error);  99: }  //////////////////////////////////////////////////////////////////////  100: task void RecvToAPP_task(){  101: memcpy(&NWKF, ...);  102: signal RecvToAPP.receive(...);  103: }  104: task void Forwarding_task(){  105: if (call SendToMAC.send(...))==SUCCESS)  106: insertMSGtoRTable(&ForwardMsg[Forward_Buff_Index]);  107: }  108: event message_t* RecvFromMAC.receive(...) {  109: Route_Msg *pack = (Route_Msg *) call SendToMAC.getPayload(msg);  110: if (pack->FinalDstAddr == TOS_NODE_ID) {  111: #ifndef SHOW_OVERLAP_PACKET //Makefile 中记录的值  112: if (!isRecvPrevious(msg))  113: #endif  114: {  ...  115: post RecvToAPP_task();  116: }  117: }else{  118: if (!isRecvPrevious(msg)){  119: if (pack->TTL>0) {  120: pack->TTL--;  121: Forward_Buff_Index++;  122: Forward_Buff_Index %= MAX_Forward_Buff;  123: memcpy(...);
[实习 13] 无线 Ad-hoc Flooding 网络  271  // Change Route Field  {  124: Route_Msg Forward_NWKF;  125: memcpy (...);  126: sizeof(Route_Msg));  127: Forward_NWKF.FrameControl = ForwardDataFrame;  128: if (Forward_NWKF.Dst2_for_multihop == UnknownAddr){  129: Forward_NWKF.Dst2_for_multihop = TOS_NODE_ID;  130: }else{  131: Forward_NWKF.Dst3_for_multihop  = Forward_NWKF.Dst2_for_multihop;  132: Forward_NWKF.Dst2_for_multihop = TOS_NODE_ID;  133: }  134: memcpy (...);  135: }  136: post Forwarding_task();  137: }  138: }  139: }  140: return msg;  141: }  142: command void* RecvToAPP.getPayload(message_t* msg, uint8_t* len){  143: return call RecvFromMAC.getPayload(msg, len);  144: }  145: command uint8_t RecvToAPP.payloadLength(message_t* msg){  146: return call RecvFromMAC.payloadLength(msg);  147: }  148: event void Timer.fired() {}  149:}  23: StdControl.start() 函数是依靠 Adhoc_APPM.nc 的 call RControl.start();代码调用的  函数。在此函数中初始化 Flooding 协议中使用的多种变量。
实习篇  272  72: SendFromAPP.send 函数是为了 Adhoc_APPM.nc 中生成的 packet 依靠 Rout_Send.  send 函数被调用时而创建的函数。在此函数中,将在 application 中传递的数据包存储到 R  oute_Msg 结构体的 payload 中,并填入 flooding 时需要的路由标题字段。在代码 83 行中,  通过 SendToMAC.send 函数将生成的路由数据包传送给 AMSenderC 组件。如果向 AMSe  nderC 组件传送成功,调用 insertMSGtoRTable() 函数(85 行)将传送的数据包的信息存储  到自身的路由表中。  88~99: 是 AMSend 接口的 sub 函数的实现代码。  108: 是从 AMReceiverC 组件收到 RF 数据时被调用的 event 函数。在此函数中,首  先检查收到的数据包的最终目的地地址是否与自身的地址相同(110 行)。如果说最终目的  地地址与自身的地址相同,则通过 RecvToApp_task 函数将此数据包传给上层 application。  如果自身不是最终目的地地址,则为了转发此数据包,检查几种条件。首先,使用 isRec  vPrevious()函数,检查是否是以前传送过的数据包。如果是以前已经传送过的数据包,因  没有必要转发两次而立刻返还。但是如果是初次收到的数据包(119 行以下),首先检查数  据包的 TTL 值,检查是否比 0 大。TTL 值是 0 时,不转发此数据包。但当 TTL 值比 0 大  时,为了转发收到的数据包,将路由标题字段的值进行一些修改后,通过 Forwarding_task  ()函数将数据包传送给 AMSenderC 组件。  142~147: 是 Receive 接口的 sub 函数的实现代码。  17.4.5. Adhoc_App.h  Adhoc_App.h 头文件中定义了 application 中使用的多个定义值及 application 数据包的  结构体 Adhoc_APP_Msg。此结构体的内容如下。  typedef struct  {  uint16_t App_Seq; //Applicaton Sequence 编号  uint16_t Sender_Addr; //Sender 地址  uint16_t App_Data[DATA_MAX]; //数据  }Adhoc_APP_Msg;
[实习 13] 无线 Ad-hoc Flooding 网络  273  17.4.6. Adhoc_Route.h  Adhoc_Route.h 头文件中定义了路由层中使用的多个定义值及路由数据包的结构体 Ro  ute_Msg。此结构体的内容如下。  typedef struct {  // 路由头  uint16_t FrameControl; //传送的路由数据包 Type  uint16_t FinalDstAddr; //最终接收节点地址  uint16_t OrigiSrcAddr; //第一个产生数据的节点地址  uint8_t Sequence; //路由 Sequence 编号  uint8_t TTL; //最大数据包转发数字  uint16_t Dst2_for_multihop; //参与转发的节点地址 1  uint16_t Dst3_for_multihop; //参与转发的节点地址 2  // applicatoin 数据  Adhoc_APP_Msg AppData; //App 中使用的数据结构体  } __attribute__ ((packed)) Route_Msg;  17.5. Flooding 实习  17.5.1. 实习准备物  ======================================================= Host PC,节点若干,FLASH PROGRAMMER 工具,连接线 =======================================================  实习系统构成  17.5.2.  首先运行 cygwin。如下进行输入,移动到例题文件夹中。  cd /opt/tinyos-2.x/contrib/cc2431
实习篇  274  cd Adhoc_Flooding  现在输入 make cc2431 进行编译。  使用―make cc2431 reinstall.X‖ 命令生成从 0 号到想要编号的 hex 文件。  参照实习 1~3 章的<将编译的 hex 文件下载到节点中>将编译后生成的 hex 文件下载到  HBE-Ubi-CC2431 节点中。  17.6. 实习结果  通过串口程序确认 0 号节点传送的串行数据包,尝试分析是从哪个节点传送的数据包。  此外,更改 Makefile 的下面两行(# 删除)的同时进行测试,尝试确认 sink 收到的数据包的  输出怎样变化。  #CFLAGS += -DSHOW_ROUTE_HEADER=1 #CFLAGS += -DSHOW_OVERLAP_PACKET=1

**RFID**

实习篇  354  1: #include "RFID_Control.h"  2: configuration testRFIDwithUSNC { }  3: implementation{  4: components MainC, testRFIDwithUSNM  5: , LedsC  6: , RFID_ControlC  7: , SCSuartDBGC  8: , ActiveMessageC  9: , new AMSenderC(RFID_MSG)  10 , new AMReceiverC(RFID_MSG);  11: testRFIDwithUSNM.Boot -> MainC;  12: testRFIDwithUSNM.Leds -> LedsC;  13: testRFIDwithUSNM.RFID_Control -> RFID_ControlC;  // 以 byte 为单位的 Serial 通信  14: testRFIDwithUSNM.SCSuartSTD -> SCSuartDBGC;  15: testRFIDwithUSNM.SCSuartDBG -> SCSuartDBGC;  16: testRFIDwithUSNM.SCSuartDBGRecv -> SCSuartDBGC;  // 为了无线通信  17: testRFIDwithUSNM.CommControl -> ActiveMessageC;  18: testRFIDwithUSNM.RecvMsg -> AMReceiverC;  19: testRFIDwithUSNM.DataMsg -> AMSenderC;  20:}
[实习 17] RFID 实习  355  6: 实际控制 RFID 读卡器的组件是 RFID_ControlC 组件。此组件为了 RFID 读卡器的  控制提供了 RFID_Control 接口。  7: 在本例题中,为了简单创建与 PC 串行通信,使用不遵照 TinyOS 格式的 SCSuartD  BGC 串行组件。  21.4.2. testRFIDwithUSN.nc 文件  观察研究 testRFIDwithUSN 例题程序的模块 — testRFIDwithUSNM.nc 代码,如下所  示。  1: module testRFIDwithUSNM  2:{  3: provides interface StdControl;  4: uses {  5: interface Leds;  6: interface RFID_Control;  7: interface Boot;  8: interface StdControl as SCSuartSTD;  9: interface SCSuartDBG;  10: interface SCSuartDBGRecv;  11: interface SplitControl as CommControl;  12: interface AMSend as DataMsg;  13: interface Receive as RecvMsg;  14: }  15: }implementation{  16 : message_t RF_MSG;  17 : uint8_t OutputUartMsg[64];  18 : char Inc_Flag;  19 : void Print_MSG_AccordingTo_CMD(uint8_t RecvCMDType, uint8_t status, uint8_t *buff);  20: event void Boot.booted() {  21: call CommControl.start();
实习篇  356  22: }  23: event void CommControl.startDone(error_t error) {  24: call SCSuartSTD.start();  25: call RFID_Control.start();  26: }  27: event void CommControl.stopDone(error_t error) {  28: }  // 从串口收到特定指令时,为了能够调用有关函数而构成的函数。  29: void Control_RFID(uint8_t comm, uint8_t block, uint8_t* buff) {  30: if (comm == 1) {  31: call RFID_Control.GetID_14443A();  32: }else if (comm == 2) {  33: call RFID_Control.GetID_15693 ();  34: }else if (comm == 3) {  35: call RFID_Control.RData_15693 (block);  36: }else if (comm == 4) {  37: call RFID_Control.WData_15693 (block, buff, 4);  38: }  39: }  //与串行有关的变量 ...  40: #define RecvBuffSize 8  41: uint8_t RecvBuff[RecvBuffSize];  42: uint8_t recv_num = 0;  43: bool start_flag = 0;  44: event void DataMsg.sendDone(message_t* msg, error_t error) {  45: if(error==SUCCESS)  46: call Leds.led1Off();  47: }  48: event message_t* RecvMsg.receive(message_t* msg, void* payload, uint8_t len) {  49: call Leds.led2Toggle();  50: if(TOS_NODE_ID==SinkAddress){  51: RFID_DATA_MSG *pack = (RFID_DATA_MSG *) payload;
[实习 17] RFID 实习  357  52: Print_MSG_AccordingTo_CMD(...);  53: }else{  54: RFID_COMM_MSG *pack = (RFID_COMM_MSG *) payload;  55: Control_RFID(pack->comm, pack->block, pack->wbuff);  56: }  57: return msg;  58: }  59: ///////////////////////////////////////////////////////////////  60: task void SendToReader(){  61: if (call DataMsg.send(AM_BROADCAST_ADDR, &RF_MSG, recv_num) == SUCCESS){  62: call Leds.led1On();  63: }  64: }  65: async event void SCSuartDBGRecv.UARTRecv (uint8_t recv_Char) {  66: if(recv_Char == 0x7E && start_flag ==0) {  67: recv_num = 0;  68: start_flag = 1;  69: } else if (recv_num < RecvBuffSize && start_flag ==1) {  70: RecvBuff[recv_num] = recv_Char;  71: recv_num++;  72: if (recv_num==RecvBuffSize) {  73: call Leds.led0Toggle();  74: memcpy(call DataMsg.getPayload(&RF_MSG), ...);  75: post SendToReader();  76: start_flag = 0;  77: }  78: }  79: }  ///////////////////////////////////////////////////////////////  80: task void SendToSinkAddress() {  81: if (call DataMsg.send(SinkAddress, &RF_MSG, sizeof(RFID_DATA_MSG)) == SUCCESS){  82: call Leds.led1On();
实习篇  358  83: }  84: }  85: async event void RFID_Control.GetID_14443A_Done(char status, uint8_t *buff, char size) {  86: ...  87: }  88: async event void RFID_Control.GetID_15693_Done (char status, uint8_t *buff, char size){  89: ...  90: }  91: async event void RFID_Control.RData_15693_Done (char status, uint8_t *buff, char size){  92: ...  93: }  94: async event void RFID_Control.WData_15693_Done (char status){  95: ...  96: }  ///////////////////////////////////////////////////////////////  97: void Print_MSG_AccordingTo_CMD(uint8_t RecvCMDType, uint8_t status, uint8_t *buff) {  98: uint8_t i;  99: switch(RecvCMDType){  100: case CMD_GetID_14443A:  101: if(status == 0){  102: sprintf(OutputUartMsg, "Recv 14443A ID: [");  103: ...  104: }else{  105: sprintf(OutputUartMsg, "14443A GetID Error: %d\r\n", status);  106: ...  107: }  108: break;  109: case CMD_GetID_15693:  110: if(status == 0){  111: sprintf(OutputUartMsg, "Recv 15693 ID: [");  112: ...
[实习 17] RFID 实习  359  113: }else{  114: sprintf(OutputUartMsg, "15693 GetID Error: %d\r\n", status);  115: ...  116: }  117: break;  118: case CMD_RData_15693:  119: if(status == SUCCESS){  120: sprintf(OutputUartMsg, "Read data from 15693: Data[");  121: ...  122: }else{  123: sprintf(OutputUartMsg, "Recv RData 15693 Error: %d\r\n", status);  124: ...  125: }  126: break;  127: case CMD_WData_15693:  128: if(status == SUCCESS){  129: sprintf(OutputUartMsg, "Write data to 15693 SUCCESS!!!\r\n");  130: ...  131: }else{  132: sprintf(OutputUartMsg, "Write data to 15693 Error: %d\r\n", status);  133: ...  134: }  135: break;  136: }  137: }  138:}  20~26: 在 TinyOS 开始的同时被调用的 boot 函数中调用 RF 初始化函数。在意味着 R  F 初始化结束的 startDone 函数中初始化串口和 RFID 控制组件。  65: Serial_Parsing 程序传送的指令通过 UartRecv()函数一个字节一个字节地传给节点。  在此 UartRecv() 函数中,收集 PC 传送的数据后,存储到 RF_MSG 中,调用 SendToRead  er() 任务。  60: SendToReader 函数起无线传递 PC 上传送的指令的作用。
实习篇  360  53: Sink 节点传送的 RFID 指令通过 receive 函数传递给控制节点。控制节点在第 55  行中通过 Control_RFID 函数为了给 RFID 读卡器调用适当的指令函数而创建。  85~96: 作为对 Control_RFID 函数中被调用的指令的应答,记录了各指令对应的 event  函数。在各函数中,起将作为参数收到的返还值存储在 RF_MSG 中,向 sink 节点传送的  作用。  50: 控制节点传送的返还值通过 receive 函数被传给 sink 节点,通过第 52 行被串行输  出。  21.5. TestRFIDwithUSN 实习  21.5.1. 实习准备物  ===================================================================== Host PC,2 个节点,RFID 读卡器和标签,USB_ISP 板,FLASH PROGRAMMER 工具, USB 连接线 =====================================================================  21.5.2. 实习系统构成  首先运行 cygwin。如下进行输入,移动到例题文件夹中。  cd /opt/tinyos-2.x/contrib/cc2431  cd TestRFIDwithRFID
[实习 17] RFID 实习  361  (如果没有 TestRFIDwithRFID 文件夹,请从韩伯电子主页上重新下载。)  现在输入 make cc2431 编译后,通过 make cc2431 reinstall.X 指令生成具有 0 号和 1 号  ID 的 hex 文件。  参照实习 1~3 章的<将编译的 hex 文件下载到节点中>将编译后生成的 hex 文件下载到  HBE-Ubi-CC2431 节点中。  21.6. 实习结果  为了控制 RFID,需要利用位于相同文件夹中的 Serial_Parsing.c。如下进行输入,编  译 Serial_Parsing.c。(编译前,一定要检查 Serial_Parsing.c 文件中的#define MODEMDE  VICE "/dev/ttyS0" 语句是否与当前连接的 COM 编号相符。)  gcc –o run Serial_Parsing.c  成功编译后,执行./run.exe。这时,需要给 RFID 读卡器供给 5V 电源或连接 USB 供  给电源。)  如果执行./run,则出现如下所示的画面。  如果想要读 14443A 标签的 ID,输入 a 后,再次按任意按钮。那么如下所示,可以看  到 RFID 天线附近的 14443A 标签的 ID 被输出。