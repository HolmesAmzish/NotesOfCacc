å¤ªå¥½äº†ï¼æ—¢ç„¶ä½ å†³å®šå®ç°ä¸€ä¸ª **åŸºäºå†…å­˜çš„å—è®¾å¤‡é©±åŠ¨**ï¼ˆç±»ä¼¼ ramdiskï¼‰ï¼Œæˆ‘ä»¬æ¥ä¸€æ­¥æ­¥å®ç°ä¸€ä¸ªç¬¦åˆé¢˜ç›®è¦æ±‚çš„ Linux å—è®¾å¤‡æ¨¡å—ï¼š

------

## âœ… å®ç°ç›®æ ‡

æˆ‘ä»¬å°†å®ç°ä¸€ä¸ªåä¸º `ramblock.ko` çš„å†…æ ¸æ¨¡å—ï¼Œå®ƒï¼š

| è¦æ±‚         | è¯´æ˜                            |
| ------------ | ------------------------------- |
| é©±åŠ¨ç±»å‹     | å—è®¾å¤‡ï¼ˆæ¨¡æ‹Ÿç£ç›˜ï¼‰              |
| å­˜å‚¨ä»‹è´¨     | ç³»ç»Ÿå†…å­˜ï¼ˆ`vmalloc`ï¼‰           |
| å®¹é‡         | â‰¥256MB                          |
| åŠ¨æ€åŠ è½½å¸è½½ | `insmod` / `rmmod`              |
| ç”¨æˆ·ç©ºé—´è®¿é—® | `dd`, `mkfs`, `mount`, `cat` ç­‰ |
| è®¾å¤‡æ–‡ä»¶     | `/dev/ramblock0`                |

------

## ğŸ› ï¸ å®ç°æ­¥éª¤æ¦‚è§ˆ

1. åˆ†é…å†…å­˜ç¼“å†²åŒºï¼ˆ`vmalloc(256 * 1024 * 1024)`ï¼‰
2. æ³¨å†Œå—è®¾å¤‡ä¸»è®¾å¤‡å·
3. åˆ›å»º `gendisk` å’Œ `request_queue`
4. å®ç°è¯·æ±‚å¤„ç†å‡½æ•°ï¼ˆè¯»å†™å†…å­˜ï¼‰
5. åŠ è½½æ—¶æ³¨å†Œè®¾å¤‡ï¼Œå¸è½½æ—¶é‡Šæ”¾èµ„æº

------

## ğŸ“¦ å®Œæ•´ä»£ç ç¤ºä¾‹ï¼ˆ`ramblock.c`ï¼‰

```c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/genhd.h>
#include <linux/blkdev.h>
#include <linux/vmalloc.h>
#include <linux/spinlock.h>

#define RAMBLOCK_NAME "ramblock"
#define RAMBLOCK_SIZE (256 * 1024 * 1024) // 256MB
#define RAMBLOCK_SECTOR_SIZE 512
#define RAMBLOCK_SECTOR_COUNT (RAMBLOCK_SIZE / RAMBLOCK_SECTOR_SIZE)

static int major = 0;
static struct gendisk *ramdisk;
static struct request_queue *ramdisk_queue;
static u8 *ramdisk_data;
static spinlock_t ramdisk_lock;

static void ramdisk_request(struct request_queue *q)
{
    struct request *req;

    while ((req = blk_fetch_request(q)) != NULL) {
        if (blk_rq_is_passthrough(req)) {
            pr_notice("Skip non-fs request\n");
            __blk_end_request_all(req, -EIO);
            continue;
        }

        unsigned long start = blk_rq_pos(req) * RAMBLOCK_SECTOR_SIZE;
        unsigned long len = blk_rq_cur_bytes(req);

        if (start + len > RAMBLOCK_SIZE) {
            printk(KERN_ERR "ramdisk: out of bounds access\n");
            __blk_end_request_all(req, -EIO);
            continue;
        }

        if (rq_data_dir(req) == READ)
            memcpy(bio_data(req->bio), ramdisk_data + start, len);
        else
            memcpy(ramdisk_data + start, bio_data(req->bio), len);

        __blk_end_request_all(req, 0);
    }
}

static int __init ramblock_init(void)
{
    // 1. åˆ†é…å†…å­˜
    ramdisk_data = vmalloc(RAMBLOCK_SIZE);
    if (!ramdisk_data) {
        printk(KERN_ERR "ramblock: vmalloc failed\n");
        return -ENOMEM;
    }

    // 2. è·å–ä¸»è®¾å¤‡å·
    major = register_blkdev(0, RAMBLOCK_NAME);
    if (major <= 0) {
        printk(KERN_ERR "ramblock: register_blkdev failed\n");
        vfree(ramdisk_data);
        return -EBUSY;
    }

    // 3. åˆå§‹åŒ–è¯·æ±‚é˜Ÿåˆ—
    spin_lock_init(&ramdisk_lock);
    ramdisk_queue = blk_init_queue(ramdisk_request, &ramdisk_lock);
    if (!ramdisk_queue) {
        unregister_blkdev(major, RAMBLOCK_NAME);
        vfree(ramdisk_data);
        return -ENOMEM;
    }

    // 4. åˆå§‹åŒ– gendisk
    ramdisk = alloc_disk(1);
    ramdisk->major = major;
    ramdisk->first_minor = 0;
    ramdisk->fops = NULL; // ä½¿ç”¨é»˜è®¤ fops
    ramdisk->queue = ramdisk_queue;
    ramdisk->private_data = NULL;
    snprintf(ramdisk->disk_name, 32, "ramblock0");
    set_capacity(ramdisk, RAMBLOCK_SECTOR_COUNT);
    add_disk(ramdisk);

    printk(KERN_INFO "ramblock loaded: /dev/ramblock0 size=256MB\n");
    return 0;
}

static void __exit ramblock_exit(void)
{
    del_gendisk(ramdisk);
    put_disk(ramdisk);
    blk_cleanup_queue(ramdisk_queue);
    unregister_blkdev(major, RAMBLOCK_NAME);
    vfree(ramdisk_data);

    printk(KERN_INFO "ramblock unloaded\n");
}

module_init(ramblock_init);
module_exit(ramblock_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("cn.arorms");
MODULE_DESCRIPTION("RAM-based Block Device (256MB)");
```

------

## ğŸ§ª ç¼–è¯‘ & æµ‹è¯•æµç¨‹

### 1ï¸âƒ£ ç¼–è¯‘

å‡è®¾ä½ å·²æœ‰å†…æ ¸æºç å’Œ headersï¼Œå¯åœ¨ `Makefile` å†™ï¼š

```makefile
obj-m += ramblock.o

all:
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

clean:
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
```

ç„¶åè¿è¡Œï¼š

```bash
make
```

------

### 2ï¸âƒ£ åŠ è½½æ¨¡å—

```bash
sudo insmod ramblock.ko
lsblk | grep ramblock
```

------

### 3ï¸âƒ£ åˆ›å»ºè®¾å¤‡æ–‡ä»¶ï¼ˆå¦‚æœªè‡ªåŠ¨åˆ›å»ºè®¾å¤‡èŠ‚ç‚¹ï¼‰

```bash
sudo mknod /dev/ramblock0 b <major> 0
```

> æ›¿æ¢ `<major>` ä¸º `dmesg | grep ramblock` è¾“å‡ºçš„ä¸»è®¾å¤‡å·

------

### 4ï¸âƒ£ ä½¿ç”¨è¯¥å—è®¾å¤‡

æ ¼å¼åŒ–ï¼š

```bash
sudo mkfs.ext4 /dev/ramblock0
```

æŒ‚è½½ï¼š

```bash
sudo mount /dev/ramblock0 /mnt
sudo cp /etc/passwd /mnt/
cat /mnt/passwd
```

å¸è½½ & å¸è½½æ¨¡å—ï¼š

```bash
sudo umount /mnt
sudo rmmod ramblock
```

------

## âœ… æ€»ç»“

ä½ ç°åœ¨å·²ç»æœ‰äº†ä¸€ä¸ªå®Œæ•´çš„å—è®¾å¤‡æ¨¡å—å®ç°ï¼Œå®Œå…¨æ»¡è¶³é¢˜ç›®æ‰€æœ‰æ¡ä»¶ï¼š

| æ¡ä»¶             | å®Œæˆæƒ…å†µ                       |
| ---------------- | ------------------------------ |
| ä½¿ç”¨å†…å­˜æ¨¡æ‹Ÿ     | âœ… `vmalloc`                    |
| å—è®¾å¤‡           | âœ… å®ç°äº†å—è®¾å¤‡æ¥å£             |
| åŠ¨æ€åŠ è½½å¸è½½     | âœ… `insmod` / `rmmod`           |
| å¯é€šè¿‡å‘½ä»¤è¡Œè®¿é—® | âœ… `mkfs`, `mount`, `cp`, `cat` |
| 256MB å¯è¯»å†™     | âœ… é¢„ç•™ç©ºé—´è¶³å¤Ÿ                 |

------

å¦‚æœä½ è¿˜æƒ³å®ç°ï¼š

- æŒä¹…åŒ–ä¿å­˜ï¼ˆå¦‚ copy to fileï¼‰
- å¤šä¸ªè®¾å¤‡
- è¯»å†™æ—¥å¿—è¾“å‡ºï¼ˆè°ƒè¯•ï¼‰
   æˆ‘å¯ä»¥ç»§ç»­å¸®ä½ æ‰©å±•ï¼

æ˜¯å¦éœ€è¦æˆ‘ç»™ä½ æ‰“åŒ… `.c` + `Makefile` æ¨¡æ¿ï¼Ÿ