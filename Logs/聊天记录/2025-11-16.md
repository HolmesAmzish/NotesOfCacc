# 安卓国际象棋应用开发教学文档

## 项目概述

这是一个使用Kotlin和Jetpack Compose开发的完整国际象棋应用。项目采用了现代化的安卓开发技术栈，包括：

- **Kotlin** - 主要编程语言
- **Jetpack Compose** - 声明式UI框架
- **Material Design** - 设计系统
- **MVVM架构** - 数据驱动UI

## 开发环境要求

- Android Studio Arctic Fox (2020.3.1) 或更高版本
- Android SDK 34
- Kotlin 1.9.10
- Gradle 8.4.1

## 项目结构分析

```
app/
├── src/main/
│   ├── java/cucerdariancatalin/chess/
│   │   ├── MainActivity.kt              # 应用入口点
│   │   ├── model/                       # 数据模型层
│   │   │   ├── board/                   # 棋盘相关模型
│   │   │   ├── piece/                   # 棋子模型
│   │   │   ├── game/                    # 游戏逻辑
│   │   │   └── move/                    # 移动逻辑
│   │   └── ui/                          # UI层
│   │       ├── app/                     # 应用级UI组件
│   │       ├── chess/                   # 棋盘UI组件
│   │       └── base/                    # 基础UI组件
│   └── res/                             # 资源文件
│       ├── drawable/                    # 矢量图标
│       ├── values/                      # 字符串、颜色、主题
│       └── mipmap/                      # 应用图标
```

## 第一步：项目初始化

### 1.1 创建新项目

1. 打开Android Studio
2. 选择"New Project"
3. 选择"Empty Compose Activity"
4. 配置项目信息：
   - Name: Chess
   - Package name: com.yourname.chess
   - Language: Kotlin
   - Minimum SDK: API 24

### 1.2 配置Gradle依赖

在 `app/build.gradle.kts` 中添加必要的依赖：

```kotlin
dependencies {
    implementation("androidx.core:core-ktx:1.12.0")
    implementation("androidx.appcompat:appcompat:1.6.1")
    implementation("com.google.android.material:material:1.9.0")
    implementation("androidx.activity:activity-compose:1.8.2")
    
    // Compose
    implementation("androidx.compose.runtime:runtime:1.5.1")
    implementation("androidx.compose.foundation:foundation:1.5.1")
    implementation("androidx.compose.ui:ui:1.5.1")
    implementation("androidx.compose.ui:ui-tooling:1.5.1")
    implementation("androidx.compose.material:material:1.5.1")
    implementation("androidx.compose.ui:ui-tooling-preview:1.5.1")
    implementation("androidx.compose.runtime:runtime-saveable-android:1.6.7")
}
```

## 第二步：数据模型设计

### 2.1 棋盘位置模型

创建 `Position.kt`：

```kotlin
@Parcelize
enum class Position : Parcelable {
    a1, b1, c1, d1, e1, f1, g1, h1,
    a2, b2, c2, d2, e2, f2, g2, h2,
    a3, b3, c3, d3, e3, f3, g3, h3,
    a4, b4, c4, d4, e4, f4, g4, h4,
    a5, b5, c5, d5, e5, f5, g5, h5,
    a6, b6, c6, d6, e6, f6, g6, h6,
    a7, b7, c7, d7, e7, f7, g7, h7,
    a8, b8, c8, d8, e8, f8, g8, h8;
    
    val file: File get() = File.valueOf(name.substring(0, 1))
    val rank: Int get() = name.substring(1).toInt()
    
    companion object {
        fun from(file: Int, rank: Int): Position {
            require(file in 1..8 && rank in 1..8)
            return values()[(rank - 1) * 8 + (file - 1)]
        }
    }
}
```

### 2.2 棋子基础接口

创建 `Piece.kt`：

```kotlin
interface Piece : Parcelable {
    val set: Set
    val asset: Int?
    val symbol: String
    val textSymbol: String
    val value: Int
    
    fun pseudoLegalMoves(gameSnapshotState: GameSnapshotState, checkCheck: Boolean): List<BoardMove>
}
```

### 2.3 棋子颜色枚举

创建 `Set.kt`：

```kotlin
enum class Set {
    WHITE, BLACK;
    
    val opposite: Set
        get() = when (this) {
            WHITE -> BLACK
            BLACK -> WHITE
        }
}
```

### 2.4 棋盘模型

创建 `Board.kt`：

```kotlin
@Parcelize
data class Board(
    val pieces: Map<Position, Piece>
) : Parcelable {
    constructor() : this(initialPieces)
    
    operator fun get(position: Position): Square = squares[position]!!
    
    fun pieces(set: Set): Map<Position, Piece> = 
        pieces.filter { (_, piece) -> piece.set == set }
}
```

## 第三步：棋子实现

### 3.1 兵(Pawn)实现

创建 `Pawn.kt`：

```kotlin
@Parcelize
class Pawn(override val set: Set) : Piece {
    override val value: Int = 1
    
    override val asset: Int = when (set) {
        WHITE -> R.drawable.pawn_light
        BLACK -> R.drawable.pawn_dark
    }
    
    override fun pseudoLegalMoves(gameSnapshotState: GameSnapshotState, checkCheck: Boolean): List<BoardMove> {
        // 实现兵的移动逻辑：前进、吃子、过路兵、升变
        val moves = mutableListOf<BoardMove>()
        // ... 具体实现
        return moves
    }
}
```

### 3.2 其他棋子实现

类似地实现其他棋子：
- `Rook.kt` - 车
- `Knight.kt` - 马
- `Bishop.kt` - 象
- `Queen.kt` - 后
- `King.kt` - 王

## 第四步：游戏逻辑

### 4.1 游戏状态管理

创建 `GameState.kt`：

```kotlin
@Parcelize
data class GameState(
    val states: List<GameSnapshotState> = listOf(GameSnapshotState()),
    val currentIndex: Int = 0
) : Parcelable {
    val currentSnapshotState: GameSnapshotState get() = states[currentIndex]
    val hasNextIndex: Boolean get() = currentIndex < states.lastIndex
    val hasPrevIndex: Boolean get() = currentIndex > 0
}
```

### 4.2 游戏控制器

创建 `GameController.kt`：

```kotlin
class GameController(
    val getGamePlayState: () -> GamePlayState,
    private val setGamePlayState: ((GamePlayState) -> Unit)? = null
) {
    fun onClick(position: Position) {
        // 处理棋盘点击事件
        if (position.hasOwnPiece()) {
            toggleSelectPosition(position)
        } else if (canMoveTo(position)) {
            applyMove(selectedPosition, position)
        }
    }
    
    fun applyMove(from: Position, to: Position) {
        // 应用移动逻辑
    }
    
    fun stepForward() { /* 前进一步 */ }
    fun stepBackward() { /* 后退一步 */ }
}
```

## 第五步：UI界面实现

### 5.1 主活动

更新 `MainActivity.kt`：

```kotlin
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            ChessoTheme {
                Surface(color = MaterialTheme.colors.background) {
                    Game()
                }
            }
        }
    }
}
```

### 5.2 游戏主界面

创建 `Game.kt`：

```kotlin
@Composable
fun Game(
    state: GamePlayState = GamePlayState(),
    importGameText: String? = null
) {
    var isFlipped by rememberSaveable { mutableStateOf(false) }
    val gamePlayState = rememberSaveable { mutableStateOf(state) }
    
    val gameController = remember {
        GameController(
            getGamePlayState = { gamePlayState.value },
            setGamePlayState = { gamePlayState.value = it }
        )
    }
    
    Column(
        modifier = Modifier
            .fillMaxSize()
            .background(MaterialTheme.colors.background)
    ) {
        Status(gamePlayState.value.gameState)
        Moves(gamePlayState.value.gameState.moves())
        Board(
            gamePlayState = gamePlayState.value,
            gameController = gameController,
            isFlipped = isFlipped
        )
        GameControls(
            gamePlayState = gamePlayState.value,
            onStepBack = { gameController.stepBackward() },
            onStepForward = { gameController.stepForward() },
            onFlipBoard = { isFlipped = !isFlipped }
        )
    }
}
```

### 5.3 棋盘组件

创建 `Board.kt`：

```kotlin
@Composable
fun Board(
    gamePlayState: GamePlayState,
    gameController: GameController,
    isFlipped: Boolean = false
) {
    BoxWithConstraints(
        modifier = Modifier
            .fillMaxWidth()
            .aspectRatio(1f)
    ) {
        val squareSize = maxWidth / 8
        
        // 渲染棋盘格子
        for (position in Position.values()) {
            val displayPosition = if (isFlipped) position.flipped() else position
            Square(
                position = displayPosition,
                squareSize = squareSize,
                piece = gamePlayState.gameState.currentSnapshotState.board[position].piece,
                onClick = { gameController.onClick(position) }
            )
        }
    }
}
```

### 5.4 单个格子组件

创建 `Square.kt`：

```kotlin
@Composable
fun Square(
    position: Position,
    squareSize: Dp,
    piece: Piece?,
    onClick: () -> Unit
) {
    val color = if ((position.file.ordinal + position.rank) % 2 == 0) {
        Color.LightGray
    } else {
        Color.DarkGray
    }
    
    Box(
        modifier = Modifier
            .size(squareSize)
            .background(color)
            .clickable(onClick = onClick),
        contentAlignment = Alignment.Center
    ) {
        piece?.let {
            PieceImage(piece = it)
        }
    }
}
```

## 第六步：资源文件配置

### 6.1 字符串资源

创建 `strings.xml`：

```xml
<resources>
    <string name="app_name">Chesso</string>
    <string name="action_previous_move">Previous move</string>
    <string name="action_next_move">Next move</string>
    <string name="action_flip">Flip the board</string>
    <string name="resolution_white_to_move">WHITE to move</string>
    <string name="resolution_black_to_move">BLACK to move</string>
</resources>
```

### 6.2 颜色主题

创建 `themes.xml`：

```xml
<style name="Theme.Chesso" parent="Theme.MaterialComponents.DayNight.DarkActionBar">
    <item name="colorPrimary">@color/space_cadet</item>
    <item name="colorPrimaryVariant">@color/manatee</item>
    <item name="colorOnPrimary">@color/white</item>
</style>
```

### 6.3 棋子图标

准备棋子图标资源：
- `pawn_light.xml` - 白兵
- `pawn_dark.xml` - 黑兵
- 其他棋子类似

## 第七步：高级功能实现

### 7.1 移动验证

在游戏控制器中添加移动验证逻辑：

```kotlin
private fun findBoardMove(from: Position, to: Position): BoardMove? {
    val legalMoves = gameSnapshotState
        .legalMovesFrom(from)
        .filter { it.to == to }
    
    return when {
        legalMoves.isEmpty() -> null
        legalMoves.size == 1 -> legalMoves.first()
        else -> handlePromotion(to, legalMoves)
    }
}
```

### 7.2 特殊规则

实现国际象棋特殊规则：
- 王车易位
- 过路兵
- 兵升变
- 将军和将死检测

### 7.3 数据可视化

添加棋盘状态可视化：

```kotlin
@Composable
fun BoardDecoration(
    properties: BoardRenderProperties,
    visualisation: DatasetVisualisation
) {
    // 渲染可能的移动、攻击范围等可视化信息
}
```

## 第八步：测试和调试

### 8.1 单元测试

创建棋子移动测试：

```kotlin
@Test
fun testPawnInitialMoves() {
    val gameState = GamePlayState()
    val pawn = gameState.gameState.currentSnapshotState.board[a2].piece as Pawn
    
    val moves = pawn.pseudoLegalMoves(gameState.gameState.currentSnapshotState, true)
    assertTrue(moves.any { it.to == a3 })
    assertTrue(moves.any { it.to == a4 })
}
```

### 8.2 UI预览

添加Compose预览：

```kotlin
@Preview(showBackground = true)
@Composable
fun GamePreview() {
    ChessoTheme {
        Game()
    }
}
```

## 第九步：构建和发布

### 9.1 构建配置

配置发布版本：

```kotlin
buildTypes {
    release {
        isMinifyEnabled = true
        proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro")
    }
}
```

### 9.2 应用清单

配置 `AndroidManifest.xml`：

```xml
<application
    android:icon="@mipmap/ic_launcher"
    android:label="@string/app_name"
    android:theme="@style/Theme.Chesso">
    
    <activity
        android:name=".MainActivity"
        android:exported="true"
        android:screenOrientation="portrait">
        
        <intent-filter>
            <action android:name="android.intent.action.MAIN" />
            <category android:name="android.intent.category.LAUNCHER" />
        </intent-filter>
    </activity>
</application>
```

## 开发要点总结

1. **架构清晰**：采用分层架构，分离数据模型、业务逻辑和UI
2. **状态管理**：使用不可变状态和状态提升模式
3. **响应式UI**：利用Compose的声明式特性
4. **国际象棋规则**：完整实现所有标准规则
5. **用户体验**：提供直观的交互和视觉反馈

## 扩展功能建议

- 添加PGN导入/导出功能
- 实现AI对手
- 添加游戏历史记录
- 支持在线对战
- 添加教学模式

按照这个文档的步骤，你可以从零开始构建一个功能完整的国际象棋安卓应用。每个步骤都包含了必要的代码示例和实现细节。


// 创建一个更精确的缩放样式
const style = document.createElement('style');
style.textContent = `
  * {
    font-size: 99% !important;
  }
  
  /* 处理特殊情况 */
  input, textarea, select, button {
    font-size: 99% !important; /* 表单元素保持正常大小 */
  }
`;
document.head.appendChild(style);