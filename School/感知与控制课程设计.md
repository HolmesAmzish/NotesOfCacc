江苏大学计算机学院
课程设计报告





课程名称      感知与控制课程设计      
实验学期  24  至  25  学年，第 2 学期
学生姓名        何文斌、盛子涵        
专业班级          物联网2303          
学    号     3230611069、3230611081    
指导教师             李峰             
完成时间           2025.6.25           







# 实验目的与要求
## 1.1 实验目的

1. 了解现场网感知与控制的基本方法。 

2. 掌握基于RS232的协议设计与通信方法，在此基础上实现对现场设备状态数据的采集、对设备的控制。 

3. 针对快递柜系统设计实现一个对现场快递柜状态数据采集、显示、参数设置、抽屉打开、保鲜控制等功能软件系统。 

## 1.2 实验要求
2人一组独立完成实验，分工明确，实现平台与编程语言（工具）不限，并在此基础上按附件格式要求完成课程设计实验报告。

# 2. 实验设计
  本系统采用前后端分离的B/S（浏览器/服务器）架构，整体设计分为三层：硬件模拟层、后端控制层和前端展示层。

## 2.1 实验分工
后端：何文斌
前端：盛子涵
## 2.2 总体架构

前端Web界面：通过WebSocket与后端建立持久连接，实时接收并展示快递柜状态，同时通过发送HTTP POST请求来调用后端的控制API。
后端服务：使用Python Flask框架构建，通过 pyserial 库与虚拟串口进行通信。它负责协议的编解码、业务逻辑处理，并通过 Flask-SocketIO 将状态变更实时推送给所有连接的前端客户端。
## 2.3 后端模块设计
后端系统主要由两个核心模块组成：locker_controller.py 和 app.py。
### 2.3.1 LockerController 类
这是一个面向对象的封装，将所有与硬件直接交互的底层逻辑隔离开来，实现了高内聚、低耦合。
连接管理： connect() 和 disconnect() 方法负责串口的打开、关闭以及后台监听线程的启动与停止。
数据收发： _listen_for_data() 在一个独立的线程中运行，持续监听串口数据，确保主线程不被阻塞。_send_frame() 负责将构建好的命令帧写入串口。
协议处理：
_build_frame() 系列方法负责根据功能号和数据，构建符合协议规范的完整数据帧，包括帧头、帧长、CRC校验和帧尾的计算与添加。
_parse_frame() 负责解析接收到的上行数据帧，提取出各项状态，并特别处理了字节序（Endianness）问题，确保锁状态等2字节数据被正确解析。
_decode_temperature() 等辅助函数用于处理特定数据格式的转换。
状态管理： 内部维护一个线程安全的 state 字典，存储设备的所有实时状态。
回调机制： 引入 on_update_callback 回调函数，当状态解析完成后，主动通知上层应用（app.py），实现了模块间的解耦。
### 2.3.2 app 类
该模块是连接前端与控制核心的桥梁。
Web框架： 使用 Flask搭建Web服务。
RESTful API： 为每一个控制功能（如开锁、设置温度等）都设计了清晰的API端点（如 /api/locks/open），并使用 POST 方法接收JSON格式的参数，实现了业务逻辑的标准化。
实时通信： 集成了 Flask-SocketIO，通过 socketio.emit() 将 LockerController 回调传来的最新状态，以WebSocket事件的形式广播给所有前端客户端，实现了数据的实时推送。
跨域支持： 使用 Flask-CORS 解决了前后端分离开发中常见的跨域问题，允许部署在不同域的前端页面访问后端API。

## 2.4 前端模块设计

### 2.4.1 技术栈与架构
前端采用 React 框架集合 Electron 技术栈构建，具体技术组成如下：
React：构建用户界面的核心框架，通过组件化的方式快速构建管理。
Vite：作为前端构建工具与开发服务器，并提供项目生命周期管理
Electron：用于打包成跨平台桌面应用
TailwindCSS：提供原子化样式设计与控制
除此之外，还有 Socket.IO Client、EChart.js、React Router 等等库与组件。

### 2.4.2 功能模块划分
前端系统主要分为状态监控模块与控制操作模块。状态监控模块首先向后端发送一个状态查询请求，当后端返回一个正常的响应和消息体时，前端会根据消息体内的详细内容进行页面的初始化，动态的更新前端组件的数量和显示内容。同时与后端建立 Websocket 链接并实时通信，接受后端根据虚拟程序接收到的信息帧广播的消息体，实现对后端状态的监控。同时使用 EChart.js 库实现对数据的实时显示。控制操作模块通过对后端 API 的调用，发送对应的 JSON 信息体参数发送给后端实现控制。

### 2.4.3 状态管理与实时通信实现
前端采用React的useState和useEffect钩子进行状态管理，主要状态包括：

设备状态(status)：存储从后端获取的完整设备状态、温度历史(temperatureHistory)：存储最近60个温度采样点用于可视化、WebSocket连接状态(socket)：管理实时通信连接

WebSocket通信实现特点：
1. 自动重连机制：配置了5次重连尝试，每次间隔1秒
2. 错误处理：监听connect_error事件并显示用户友好提示
3. 状态更新：通过update_status事件接收后端推送，更新状态和温度历史
4. 初始状态获取：在组件挂载时同步获取初始状态

### 2.4.4 温度可视化实现
使用ECharts库实现温度变化曲线图，主要特性包括：

实时更新：每当收到新温度数据时自动更新图表，使用线性渐变实现曲线下方区域填充效果，监听窗口resize事件自动调整图表尺寸限制历史数据长度为60个点，防止内存过度占用。

### 2.4.5 组件化设计
前端采用模块化组件设计，主要组件包括：

1. StatusPanel：显示设备当前状态（锁状态、温度等）
2. ControlsPanel：提供控制操作按钮（开锁、设置温度等）
   
   温度控制：支持设置目标温度(-20°C~40°C)，通过POST /api/temperature接口与后端交互
   
   锁控制：支持多锁同时控制，输入格式为"1,3,5"，通过POST /api/locks/open接口实现
   
   压缩机控制：提供手动启动/停止功能，通过POST /api/compressor/manual接口控制
   
   自动温控：支持启用/禁用自动温度控制模式，通过POST /api/compressor/auto接口设置
   
   温度偏差：可设置温度控制偏差值，通过POST /api/temperature/deviation接口配置
3. TemperatureChart：温度变化可视化图表
4. SystemSettingsPanel：系统参数设置面板
5. DataViewPanel：原始数据查看面板

各组件通过props接收状态数据，通过回调函数与父组件通信，实现了高内聚低耦合的设计目标。

### 2.4.6 控制面板业务逻辑
ControlsPanel组件实现了快递柜系统的核心控制功能：

1. 温度控制：
   
   用户输入目标温度后，前端验证范围，通过fetch API发送POST请求到后端，处理响应状态，显示成功/错误提示，温度设置后通过WebSocket接收实时更新。
   
2. 锁控制：
   
   解析用户输入的锁编号(如"1,3,5")
   
   转换为数组格式发送到后端，处理开锁结果，清空输入框，锁状态变化通过WebSocket实时更新。

3. 压缩机控制：
   
   提供手动启动/停止按钮，根据当前状态禁用相应按钮，操作结果通过WebSocket实时反馈。
   
4. 自动温控模式：
   
   显示当前模式状态(AUTO/MANUAL)，根据状态高亮相应按钮，模式切换后自动更新界面。
   
5. 状态管理：
   
   使用isSubmitting状态防止重复提交，统一错误处理机制，所有控制操作不影响实时数据更新。

# 3. 关键问题与解决方案
在开发过程中，遇到并解决了多个关键的技术挑战，这些是从理论走向实践的必经之路。
## 3.1 串口无法发现的问题
问题描述：
初期使用 serial.tools.list_ports.comports() 无法找到由虚拟串口软件（VSPD）创建的COM口。
分析与解决：
通过检查设备管理器，发现VSPD将虚拟串口注册在了非标准的 "Virtual Serial Port" 类别下，导致 pyserial 无法在标准的 "端口 (COM 和 LPT)" 类别中找到它们。最终通过更换为更标准、兼容性更好的虚拟串口工具 com0com，成功解决了该问题。 这次经历让我深刻理解了操作系统驱动模型与应用程序权限之间的关系。
## 3.2 字节序导致的数据解析错误
问题描述：
发送开锁指令 [0, 5]（对应控制掩码 0x0021）后，模拟器实际打开的却是其他不相关的锁；同时，从设备读取到的锁状态也与预期不符。
分析与解决：
通过对协议示例和实际结果进行反推，我们断定：设备期望接收的是小端序 (Little-Endian) 数据，而我们的代码默认生成的是大端序 (Big-Endian)。 解决方案是在发送2字节数据（如锁控制位）前，手动将其字节顺序进行反转（如 0021 -> 2100）。同理，在解析接收到的2字节锁状态时，也进行一次字节反转，从而得到了正确的状态。这个问题是嵌入式和底层通信开发中的经典难题，解决它加深了我对数据在不同系统间表示方式的理解。
## 3.3 实时数据更新方案的演进
问题描述：
最初考虑使用前端定时轮询（Polling）GET /api/status 接口来获取状态，但这会导致延迟和不必要的网络开销。
分析与解决：
为了追求更优的用户体验和更高的系统效率，我们放弃了轮询方案，转而采用基于 Flask-SocketIO 的 WebSocket 技术。通过在 LockerController 中设计回调机制，实现了后端状态更新后主动向前端推送消息。这不仅大大降低了网络延迟，实现了真正的实时监控，也让整个系统架构更为先进和高效。

# 4. 实验结果与分析

## 4.1 后端接口实现

后端系统基于Flask框架构建，实现了完整的控制接口体系。状态查询接口(/api/status)采用GET方法，通过调用controller.get_current_state()获取设备当前完整状态，包括温度、锁状态和压缩机状态等信息。

温度控制接口(/api/temperature)使用POST方法，接收{"temperature": float}格式的参数，调用controller.set_temperature()设置目标温度，有效范围为-20°C~40°C。对于无效的温度值会返回400错误。

锁控制接口(/api/locks/open)同样采用POST方法，接收{"indices": [int]}格式的参数，通过controller.open_locks()实现指定编号锁的开启功能。系统会对锁编号进行有效性验证，无效索引将返回400错误。

压缩机控制分为手动和自动两种模式。手动控制接口(/api/compressor/manual)通过POST方法接收{"start": bool}参数来控制压缩机启停；自动控制接口(/api/compressor/auto)则使用{"enable": bool}参数来切换自动温控模式。

系统参数接口(/api/system/parameters)采用POST方法接收完整的系统参数对象，用于设置系统级参数。该接口调用会触发设备复位操作，需要谨慎使用。

所有接口都实现了严格的参数验证机制，返回标准化的JSON响应格式。系统通过Flask-CORS中间件解决跨域访问问题，确保前端应用可以安全调用这些API接口。

## 4.2 实时通信机制

系统采用WebSocket技术实现实时通信。当设备状态发生变化时，后端会通过socket.io立即推送给所有连接的客户端。新连接的客户端会立即收到完整的状态数据，确保界面显示的一致性。系统还提供了手动请求状态的机制，方便前端在需要时主动获取最新数据。

## 4.3 错误处理设计

系统对可能出现的异常情况进行了全面捕获，包括无效参数、硬件通信失败等。对于服务器内部错误会返回500状态码并记录详细日志，同时给用户返回友好的提示信息。这种分层错误处理机制既方便问题排查，又提升了用户体验。

## 4.4 系统运行效果

系统运行稳定，所有设计功能均正常实现。接口响应迅速，实时数据推送延迟低，完全满足快递柜控制系统的业务需求。通过本次实现，验证了基于Flask和WebSocket构建实时控制系统的可行性。
# 5. 总结与心得
通过本次课程设计，我不仅仅是将课堂上学到的理论知识进行了简单的复现，更是在一个完整的、接近实际工程的项目中，将感知（数据采集与解析）、通信（串口协议）、控制（指令发送与业务逻辑）以及现代Web技术有机地结合了起来。
最大的收获在于解决实际问题的能力得到了极大的锻炼。从处理棘手的字节序问题，到选择并实现更优的WebSocket实时通信方案，每一步都让我对系统设计的复杂性和严谨性有了更深的认识。我学会了如何仔细阅读协议文档，如何通过分析数据包来调试问题，以及如何设计模块化、可扩展的软件架构。
此外，本次设计也让我体会到团队协作的重要性。与负责前端的队友进行API接口的定义和联调，使得我们能够高效地完成各自的任务，最终集成为一个功能完善的系统。
总而言之，这次课程设计是一次宝贵的实践经历，它将我所学的知识串联成线，构建成面，让我对“感知与控制”这一领域有了更具体、更深刻的理解。
