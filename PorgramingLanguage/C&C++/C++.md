# C++ 程序结构

## 变量的类型

### 全局变量与局部变量。

**全局变量**是指定义在函数体外部的变量，它能被所有函数调用。**局部变量**是定义在函数体或者复合语句中的变量，它只能被本函数和复合语句调用。

### 变量的存储类型

1. auto 说明符

   auto说明符说明定义的是一个局部变量。函数中的局部变量，如果不使用关键字static加以声明，编译系统对他们是动态分配存储空间的。局部变量的默认存储类型为auto，所以在程序中很少使用auto说明。

2. register 说明符

   一般情况下，变量的值是存放在内存中的，当需要时由控制器发出指令将内存中该变量的值送到运算其中，经过运算器运算后，如果需要存储运算结果，再从运算器将数据送到内存存放。如果有些变量使用频繁，例如循环结构中的循环控制比那辆，反复存取内存将消耗较多时间，为了提高执行效率，C++允许将局部变量的值存放到CPU寄存器中，需要时直接从寄存器中取出来参加运算，不必到内存中存取，这种类型的局部变量陈伟寄存器变量，用关键字register声明。

3. extern 说明符

   一个完整的计算机程序很大，分成多个模块，放在不同的文件中，分开编译成目标文件，最后连接成一个完整的可执行代码。对于所有模块共同使用的局部变量，如果在所有的模块中都有定义，在连接时就会出错。办法是只在一个模块中定义该全局变量，在其他模块中用关键字extern来声明这是一个外来全局变量，即外部性变量声明。外部性变量的定义如下，其中标识符可以是变量名也可以是函数原型。

   ```c++
   extern datatype varible;
   ```

4. static 说明符

   如果希望变量在本函数调用结束后仍然存放在内存中，可被下次调用时继续使用，可以用static说明符将该函数声明为静态变量。

   ```c++
   void function() {
       static int n = 0;
       int m = 0;
       cout << n++ << "\t" << m++ << endl;
   }
   int main() {
       for (int i = 0; i < 5; i++) {
           function();
       }
       return 0;
   }
   ```

   本段代码的输出时m一直为1，n从1开始递增。

## 程序的文件结构与编译预处理命令

### 文件包含命令 #include

文件包含是指一个C++源程序通过#include命令将另一个文件（头文件，C语言或C++源文件）的全部内容包含进来。文件包含命令的一般格式如下

```c++
#include <headfile>
#include <cppfile>
```

编译时与编译器将被包含的文件内容插入到源程序中#include命令的位置，已形成新的源程序。一个大程序通常分为多个模块，并由多个程序员分别编程。有了文件包含处理功能能就可以将多个模块公用的数据或者函数集中到一个单独的文件中。这样，凡是要使用其中的数据或者调用其中的函数的程序员，只要使用文件包含处理功能将所需文件包含进来即可。

### 不带参数的宏定义

`#define`命令顶一个标识符来代替一个字符串。宏名需要用大写字母来定义，以便于区分变量名。



## 函数与参数

### 传值参数

### 模板参数

```c
template<class T>
T abc(T a, T b, T c) {
    return a + b + c;
}
```

### 引用参数

### 常量引用参数

### 返回值

一个函数可以返回一个值、一个引用或者一个常量引用。

## 动态空间分配

### new 操作符

操作符new分配了一块能够储存一个整数的空间，并将该控件的指针赋给y，y是对整数指针的引用，而*y是对整数本身的引用。要在动态分配的空间中存储一个整数值，例如10，可以使用下面的语句：

```cpp
int* y = new int;
*y = 10;

int* y = new int(10);
```

### 异常处理

### delete 操作符

动态分配的存储空间不再需要是应该把它释放。释放的的空间可以重新用来动态分配。C++操作符delete用来释放由操作符new所分配的空间。下面的语句用来释放分配给*y和一维数组x的空间；

```cpp
delete y;
delete []x;
```

# C++ 类与对象

## 概念

```cpp
class name {
public:
protected:
private:
};
```

> [!NOTE]
>
> - class 表明定义是一个类
> - public等为**存取控制属性（访问权限）**，用来控制对象成员的存取。默认访问权限为private。
> - 类的成员有**数据成员**和**函数成员**两类。类的数据成员一般用来描述该类对象的静态属性，称为**属性**；函数成员用来描述类行为或动态属性，称为**方法**。

## 构造函数与析构函数

**构造函数（constructor）**是与类名相同的再建立对象是自动调用的函数。作为类的成员函数，构造函数可以直接访问类的所有数据成员，可以是内敛函数，可以不带任何参数，可以带有参数表以默认形参值。

构造函数是一种特殊的函数，主要用来再创建对象时初始化对象，即为对象的数据成员赋予初始值。

> [!NOTE]
>
> 1. 构造函数的函数名必须与定义它的类同名
> 2. 构造函数没有返回值，如果再构造函数前加void是错误的。
> 3. 构造函数被声明定义为**公有函数**
> 4. 构造函数再在建立对象时有系统自动调用

**析构函数（destructor）**也叫拆构函数，实在对象小时之前的瞬间自动调用的函数，其形式如下

```cpp
~Function();
```

> [!NOTE]
>
> 1. 析构函数没有任何参数，不能被重载，但是可以是虚函数，一个类只有一个析构函数。
> 2. 析构函数没有返回值
> 3. 析构函数名在类名钱加上一个逻辑非运算符“~”，以与构造函数相区别
> 4. 析构函数一般由用户自己定义，在对象小时时由系统自动调用，如果用户没有定义析构函数，系统将自动生成一个不做任何事的默认析构函数。

```cpp
#include <iostream>

class Clock {
    private:
    int H, M, S;
    public:
    Clock(int h = 0, int m = 0, int s = 0) {
        H = h, M = m, S = s;
        std::cout << "constructor: " << H << ':' << M << ':' << S << std::endl;
    }
    ~Clock() {
        std::cout << "destructor: " << H << ':' << M << ':' << S << std::endl;
    }
};

Clock C1(9, 30, 0);

int main() {
    Clock C2(10, 0, 0);
    return 0;
}	
```

这段代码的输出为：

```
constructor: 9:30:0
constructor: 10:0:0
destructor: 10:0:0
destructor: 9:30:0
```

> [!NOTE]
>
> 从运行结果来看，构造函数执行的顺序为C1::Clock() -> C2::Clock()，析构函数调用的顺序为C2::Clock() -> C1::Clock()，因为对象在栈中建立，因此小时的顺序与建立的顺序相反。

## 对象的使用

### 对象指针

对象和一般变量一样，占用一块连续的内存区域，因此可以使用一个指向对象的指针来访问对象，即**对象指针**，他只想存放该对象的地址。建立对象指针并没有建立对象，所以此时不调用构造函数。如同通过对象名访问对象成员一样，使用对象指针也之恶能访问该类的共有数据成员，但与使用`.`运算符不同，对象指针采用`->`运算符访问共有数据成员和成员函数。例如：

```cpp
Clock C1(8, 0, 0);
Clock *Cptr;
Cptr = &C1;
Cp -> DisplayTime();
```

### 对象引用

```cpp
Clock C1(8, 20, 20);
Clock &Cr = C1;
Cr.DisplayTime();
```

### 对象数组

**对象数组**是以对象为元素的数组，对象数组的定义，赋值引用与普通数组一样，只是数组元素与普通数组的数组元素不同。

### 动态对象

**动态对象**时指编程者随时动态建立并可随时消失的对象。建立动态对象采用的动态申请内存的语句new，删除动态对象使用delete语句。建立一个动态对象的格式如下：

> [!NOTE]
>
> - 对象指针的类型应该与类名一致
> - 动态对象储存在new语句从堆中申请的空间
> - 建立动态对象时要调用构造函数

```cpp
Clock * Cp;
Cp = new Clock;
Cp -> DisplayTime();
cp = new Clock(8, 0, 0);
cp -> DisplayTime();
delete Cp;
```

### this指针

this指针是一个系统预定义的特殊指针，指向当前对象，表示当前对象的地址

```cpp
void Clock::SetTime(int h, int m, int s) {
    H = h, M = m, S = s;
    this->H = h, this->M = m, this->S = s;
    // this指向当前对象。
}
```





## 静态成员

# C++标准模板库

STL（Standard Template Library）标准模板库时泛型程序设计思想在C++中的具体应用。

## STL容器

**顺序容器**以逻辑线性排列方式储存一个元素序列，这些容器类型中的对象在逻辑上被认为是在连续的储存空间中储存的。在顺序容器中的对象有相对于容器的逻辑位置，例如在容器的起始、末尾等。顺序容器可以用于存储线性表类型的数据结构。在STL中，循序容器一共有三种。

| 容器类名 | 特性                                                         | 头文件     |
| -------- | ------------------------------------------------------------ | ---------- |
| vector   | 在内存中占有一块连续的空间，存储一个元素序列，可以看作一个可动态扩展的数组，而且提供月结检查，可用`[]`运算符直接存取数据。 | `<vector>` |
| list     | 双向链接列表，每个节点包含一个元素。列表中的每个元素均有指针指向前一个元素和下一个元素。 | `<list>`   |
| deque    | 在内存中不占有一块连续的空间，介于向量和列表之间，更接近于向量，适用于从两端存取数据，可用`[]`运算符直接存取数据。 |            |

### vector

| 函数名         | 功能                       |
| -------------- | -------------------------- |
| push_back()    | 向向量最后添加一个元素     |
| pop_back       |                            |
| insert         |                            |
| erase          |                            |
| clear          |                            |
| front          |                            |
| back           |                            |
| begin          |                            |
| end            |                            |
| rbegin         |                            |
| rend           |                            |
| max_size       |                            |
| size()         | 返回容器长度               |
| empty          |                            |
| capacity       |                            |
| at(n)          | 返回第n个元素              |
| swap(x)        |                            |
| operator[]     |                            |
| emplace_back() | 直接向容器最后添加这个元素 |
